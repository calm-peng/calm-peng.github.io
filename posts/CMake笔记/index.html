<!DOCTYPE html><html lang="zh-CN" mode="light" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="CMake笔记" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="说明" /><meta property="og:description" content="说明" /><link rel="canonical" href="http://calm-peng.github.io/posts/CMake%E7%AC%94%E8%AE%B0/" /><meta property="og:url" content="http://calm-peng.github.io/posts/CMake%E7%AC%94%E8%AE%B0/" /><meta property="og:site_name" content="Calm’s blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-04-14T12:53:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="CMake笔记" /><meta name="twitter:site" content="@twitter_username" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-04-14T13:17:32+08:00","datePublished":"2022-04-14T12:53:00+08:00","description":"说明","headline":"CMake笔记","mainEntityOfPage":{"@type":"WebPage","@id":"http://calm-peng.github.io/posts/CMake%E7%AC%94%E8%AE%B0/"},"url":"http://calm-peng.github.io/posts/CMake%E7%AC%94%E8%AE%B0/"}</script><title>CMake笔记 | Calm's blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Calm's blog"><meta name="application-name" content="Calm's blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://cdn.jsdelivr.net/gh/cotes2020/chirpy-images/commons/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Calm's blog</a></div><div class="site-subtitle font-italic">Discipline,Calm,Practice</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/calm-peng" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['pzh2217','163.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>CMake笔记</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>CMake笔记</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> calm-peng </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Thu, Apr 14, 2022, 12:53 PM +0800" prep="on" > Apr 14, 2022 <i class="unloaded">2022-04-14T12:53:00+08:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Thu, Apr 14, 2022, 1:17 PM +0800" prefix="Updated " > Apr 14, 2022 <i class="unloaded">2022-04-14T13:17:32+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="5519 words">30 min</span></div></div><div class="post-content"><h1 id="说明">说明</h1><p>cmake的定义是什么 ？—–高级编译配置工具</p><p>当多个人用不同的语言或者编译器开发一个项目，最终要输出一个可执行文件或者共享库（dll，so等等）这时候神器就出现了—–CMake！</p><p>所有操作都是通过编译CMakeLists.txt来完成的—简单</p><p>官 方网站是 <a href="http://www.cmake.org/">www.cmake.org</a>，可以通过访问官方网站获得更多关于 cmake 的信息</p><p>学习CMake的目的，为将来处理大型的C/C++/JAVA项目做准备</p><h1 id="cmake安装">CMake安装</h1><p>1、绝大多数的linux系统已经安装了CMake</p><p>2、Windows或某些没有安装过的linux系统，去<a href="http://www.cmake.org/HTML/Download.html">http://www.cmake.org/HTML/Download.htm</a>l 可以下载安装</p><h1 id="cmake一个helloword">CMake一个HelloWord</h1><p>1、步骤一，写一个HelloWord</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="cp">#main.cpp
</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span>  <span class="s">"hello word"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>2、步骤二，写CMakeLists.txt</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="cp">#CMakeLists.txt
#设置工程名字和版本
</span><span class="n">PROJECT</span> <span class="p">(</span><span class="n">HELLO</span> <span class="n">VERSION</span> <span class="mf">1.0</span><span class="p">)</span>
<span class="cp">#设置变量
</span><span class="n">SET</span><span class="p">(</span><span class="n">SRC_LIST</span> <span class="n">main</span><span class="p">.</span><span class="n">cpp</span><span class="p">)</span>
<span class="cp">#输出显示信息
</span><span class="n">MESSAGE</span><span class="p">(</span><span class="n">STATUS</span> <span class="s">"This is BINARY dir "</span> <span class="err">$</span><span class="p">{</span><span class="n">HELLO_BINARY_DIR</span><span class="p">})</span>

<span class="n">MESSAGE</span><span class="p">(</span><span class="n">STATUS</span> <span class="s">"This is SOURCE dir "</span><span class="err">$</span><span class="p">{</span><span class="n">HELLO_SOURCE_DIR</span><span class="p">})</span>
<span class="cp">#设置可执行文件名字，添加源文件
</span><span class="n">ADD_EXECUTABLE</span><span class="p">(</span><span class="n">hello</span> <span class="err">$</span><span class="p">{</span><span class="n">SRC_LIST</span><span class="p">})</span>
</pre></table></code></div></div><p>3、步骤三、使用cmake，生成makefile文件</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="n">cmake</span> <span class="p">.</span>

<span class="err">输出：</span>
<span class="p">[</span><span class="n">root</span><span class="err">@</span><span class="n">localhost</span> <span class="n">cmake</span><span class="p">]</span><span class="err">#</span> <span class="n">cmake</span> <span class="p">.</span>
<span class="n">CMake</span> <span class="n">Warning</span> <span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="n">in</span> <span class="n">CMakeLists</span><span class="p">.</span><span class="n">txt</span><span class="o">:</span>
  <span class="n">Syntax</span> <span class="n">Warning</span> <span class="n">in</span> <span class="n">cmake</span> <span class="n">code</span> <span class="n">at</span>

    <span class="o">/</span><span class="n">root</span><span class="o">/</span><span class="n">cmake</span><span class="o">/</span><span class="n">CMakeLists</span><span class="p">.</span><span class="n">txt</span><span class="o">:</span><span class="mi">7</span><span class="o">:</span><span class="mi">37</span>

  <span class="n">Argument</span> <span class="n">not</span> <span class="n">separated</span> <span class="n">from</span> <span class="n">preceding</span> <span class="n">token</span> <span class="n">by</span> <span class="n">whitespace</span><span class="p">.</span>
<span class="n">This</span> <span class="n">warning</span> <span class="n">is</span> <span class="k">for</span> <span class="n">project</span> <span class="n">developers</span><span class="p">.</span>  <span class="n">Use</span> <span class="o">-</span><span class="n">Wno</span><span class="o">-</span><span class="n">dev</span> <span class="n">to</span> <span class="n">suppress</span> <span class="n">it</span><span class="p">.</span>

<span class="o">--</span> <span class="n">The</span> <span class="n">C</span> <span class="n">compiler</span> <span class="n">identification</span> <span class="n">is</span> <span class="n">GNU</span> <span class="mf">10.2.1</span>
<span class="o">--</span> <span class="n">The</span> <span class="n">CXX</span> <span class="n">compiler</span> <span class="n">identification</span> <span class="n">is</span> <span class="n">GNU</span> <span class="mf">10.2.1</span>
<span class="o">--</span> <span class="n">Check</span> <span class="k">for</span> <span class="n">working</span> <span class="n">C</span> <span class="n">compiler</span><span class="o">:</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">cc</span>
<span class="o">--</span> <span class="n">Check</span> <span class="k">for</span> <span class="n">working</span> <span class="n">C</span> <span class="n">compiler</span><span class="o">:</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">cc</span> <span class="o">--</span> <span class="n">works</span>
<span class="o">--</span> <span class="n">Detecting</span> <span class="n">C</span> <span class="n">compiler</span> <span class="n">ABI</span> <span class="n">info</span>
<span class="o">--</span> <span class="n">Detecting</span> <span class="n">C</span> <span class="n">compiler</span> <span class="n">ABI</span> <span class="n">info</span> <span class="o">-</span> <span class="n">done</span>
<span class="o">--</span> <span class="n">Check</span> <span class="k">for</span> <span class="n">working</span> <span class="n">CXX</span> <span class="n">compiler</span><span class="o">:</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">c</span><span class="o">++</span>
<span class="o">--</span> <span class="n">Check</span> <span class="k">for</span> <span class="n">working</span> <span class="n">CXX</span> <span class="n">compiler</span><span class="o">:</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">c</span><span class="o">++</span> <span class="o">--</span> <span class="n">works</span>
<span class="o">--</span> <span class="n">Detecting</span> <span class="n">CXX</span> <span class="n">compiler</span> <span class="n">ABI</span> <span class="n">info</span>
<span class="o">--</span> <span class="n">Detecting</span> <span class="n">CXX</span> <span class="n">compiler</span> <span class="n">ABI</span> <span class="n">info</span> <span class="o">-</span> <span class="n">done</span>
<span class="o">--</span> <span class="n">This</span> <span class="n">is</span> <span class="n">BINARY</span> <span class="n">dir</span> <span class="o">/</span><span class="n">root</span><span class="o">/</span><span class="n">cmake</span>
<span class="o">--</span> <span class="n">This</span> <span class="n">is</span> <span class="n">SOURCE</span> <span class="n">dir</span> <span class="o">/</span><span class="n">root</span><span class="o">/</span><span class="n">cmake</span>
<span class="o">--</span> <span class="n">Configuring</span> <span class="n">done</span>
<span class="o">--</span> <span class="n">Generating</span> <span class="n">done</span>
<span class="o">--</span> <span class="n">Build</span> <span class="n">files</span> <span class="n">have</span> <span class="n">been</span> <span class="n">written</span> <span class="n">to</span><span class="o">:</span> <span class="o">/</span><span class="n">root</span><span class="o">/</span><span class="n">cmake</span>
</pre></table></code></div></div><p>目录下就生成了这些文件-CMakeFiles, CMakeCache.txt, cmake_install.cmake 等文件，并且生成了Makefile. 现在不需要理会这些文件的作用，以后你也可以不去理会。最关键的是，它自动生成了Makefile.</p><p>4、使用make命令编译</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">root</span><span class="err">@</span><span class="n">localhost</span> <span class="n">cmake</span><span class="p">]</span><span class="err">#</span> <span class="n">make</span>
<span class="n">Scanning</span> <span class="n">dependencies</span> <span class="n">of</span> <span class="n">target</span> <span class="n">hello</span>
<span class="p">[</span><span class="mi">100</span><span class="o">%</span><span class="p">]</span> <span class="n">Building</span> <span class="n">CXX</span> <span class="n">object</span> <span class="n">CMakeFiles</span><span class="o">/</span><span class="n">hello</span><span class="p">.</span><span class="n">dir</span><span class="o">/</span><span class="n">main</span><span class="p">.</span><span class="n">cpp</span><span class="p">.</span><span class="n">o</span>
<span class="n">Linking</span> <span class="n">CXX</span> <span class="n">executable</span> <span class="n">hello</span>
<span class="p">[</span><span class="mi">100</span><span class="o">%</span><span class="p">]</span> <span class="n">Built</span> <span class="n">target</span> <span class="n">hello</span>
</pre></table></code></div></div><p>5、最终生成了Hello的可执行程序</p><h1 id="cmake一个helloword-的语法介绍">CMake一个HelloWord-的语法介绍</h1><p>参考<a href="https://llvm.org/docs/CMakePrimer.html">LLVM-CMake 入门</a></p><h2 id="project关键字">PROJECT关键字</h2><p>可以用来指定工程的名字和支持的语言，默认支持所有语言</p><p>PROJECT (HELLO) 指定了工程的名字，并且支持所有语言—建议</p><p>PROJECT (HELLO CXX) 指定了工程的名字，并且支持语言是C++</p><p>PROJECT (HELLO C CXX) 指定了工程的名字，并且支持语言是C和C++</p><p>该指定隐式定义了两个CMAKE的变量</p><p><code class="language-plaintext highlighter-rouge">&lt;projectname&gt;_BINARY_DIR</code>，本例中是 HELLO_BINARY_DIR</p><p><code class="language-plaintext highlighter-rouge">&lt;projectname&gt;_SOURCE_DIR</code>，本例中是 HELLO_SOURCE_DIR</p><p>MESSAGE关键字就可以直接使用者两个变量，当前都指向当前的工作目录，后面会讲外部编译</p><p>问题：如果改了工程名，这两个变量名也会改变</p><p>解决：又定义两个预定义变量：PROJECT_BINARY_DIR和PROJECT_SOURCE_DIR，这两个变量和HELLO_BINARY_DIR，HELLO_SOURCE_DIR是一致的。所以改了工程名也没有关系</p><h2 id="set关键字">SET关键字</h2><p>用来显示的指定变量的</p><p>SET(SRC_LIST main.cpp) SRC_LIST变量就包含了main.cpp</p><p>也可以 SET(SRC_LIST main.cpp t1.cpp t2.cpp)</p><h2 id="message关键字">MESSAGE关键字</h2><p>向终端输出用户自定义的信息</p><p>主要包含三种信息：</p><ul><li>SEND_ERROR，产生错误，生成过程被跳过。<li>SATUS，输出前缀为—的信息。<li>FATAL_ERROR，立即终止所有 cmake 过程.</ul><h2 id="add_executable关键字">ADD_EXECUTABLE关键字</h2><p><strong>生成可执行文件</strong></p><p>ADD_EXECUTABLE(hello ${SRC_LIST}) 生成的可执行文件名是hello，源文件<strong>读取变量SRC_LIST中</strong>的内容</p><p>也可以直接写 ADD_EXECUTABLE(hello main.cpp)</p><p>上述例子可以简化的写成</p><p>PROJECT(HELLO) ADD_EXECUTABLE(hello main.cpp)</p><blockquote><p>注意：工程名的 HELLO 和生成的可执行文件 hello 是没有任何关系的</p></blockquote><h1 id="语法的基本原则">语法的基本原则</h1><ul><li><strong>变量使用${}方式取值</strong>，但是在 <strong>IF 控制语句中是直接使用变量名</strong><li><p>指令(参数 1 参数 2…) 参数使用括弧括起，参数之间使用<strong>空格或分号</strong>分开。 以上面的 ADD_EXECUTABLE 指令为例，如果存在另外一个 func.cpp 源文件</p><p>就要写成：ADD_EXECUTABLE(hello main.cpp func.cpp)或者ADD_EXECUTABLE(hello main.cpp;func.cpp)</p><li><strong>指令是大小写无关的，参数和变量是大小写相关的。</strong>但，推荐你全部使用大写指令</ul><h2 id="语法注意事项">语法注意事项</h2><ul><li>SET(SRC_LIST main.cpp) 可以写成 SET(SRC_LIST “main.cpp”)，如果源文件名中<strong>含有空格</strong>，就必须要<strong>加双引号</strong><li>ADD_EXECUTABLE(hello main) <strong>后缀可以不写</strong>，他会自动去找.c和.cpp，最好不要这样写，可能会有这两个文件main.cpp和main</ul><h1 id="内部构建和外部构建">内部构建和外部构建</h1><ul><li>上述例子就是内部构建，他生产的临时文件特别多，不方便清理<li>外部构建，就会把生成的临时文件放在build目录下，不会对源文件有任何影响强烈使用外部构建方式</ul><h2 id="外部构建方式举例">外部构建方式举例</h2><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="c1">//例子目录，CMakeLists.txt和上面例子一致</span>
<span class="p">[</span><span class="n">root</span><span class="err">@</span><span class="n">localhost</span> <span class="n">cmake</span><span class="p">]</span><span class="err">#</span> <span class="n">pwd</span>
<span class="o">/</span><span class="n">root</span><span class="o">/</span><span class="n">cmake</span>
<span class="p">[</span><span class="n">root</span><span class="err">@</span><span class="n">localhost</span> <span class="n">cmake</span><span class="p">]</span><span class="err">#</span> <span class="n">ll</span>
<span class="n">total</span> <span class="mi">8</span>
<span class="o">-</span><span class="n">rw</span><span class="o">-</span><span class="n">r</span><span class="o">--</span><span class="n">r</span><span class="o">--</span><span class="p">.</span> <span class="mi">1</span> <span class="n">root</span> <span class="n">root</span> <span class="mi">198</span> <span class="n">Dec</span> <span class="mi">28</span> <span class="mi">20</span><span class="o">:</span><span class="mi">59</span> <span class="n">CMakeLists</span><span class="p">.</span><span class="n">txt</span>
<span class="o">-</span><span class="n">rw</span><span class="o">-</span><span class="n">r</span><span class="o">--</span><span class="n">r</span><span class="o">--</span><span class="p">.</span> <span class="mi">1</span> <span class="n">root</span> <span class="n">root</span>  <span class="mi">76</span> <span class="n">Dec</span> <span class="mi">28</span> <span class="mo">00</span><span class="o">:</span><span class="mi">18</span> <span class="n">main</span><span class="p">.</span><span class="n">cpp</span>
</pre></table></code></div></div><p>1、建立一个build目录，可以在任何地方，建议在当前目录下</p><p>2、进入build，运行cmake .. 当然..表示上一级目录，你可以写CMakeLists.txt所在的绝对路径，生产的文件都在build目录下了</p><p>3、在build目录下，运行make来构建工程</p><p>注意外部构建的两个变量</p><p>1、HELLO_SOURCE_DIR 还是工程路径</p><p>2、HELLO_BINARY_DIR 编译路径 也就是 /root/cmake/bulid</p><h1 id="让hello-world看起来更像一个工程">让Hello World看起来更像一个工程</h1><ul><li>为工程添加一个子目录 src，用来放置工程源代码<li>添加一个子目录 doc，用来放置这个工程的文档 hello.txt<li>在工程目录添加文本文件 COPYRIGHT, README<li>在工程目录添加一个 <a href="http://runhello.sh/">runhello.sh</a> 脚本，用来调用 hello 二进制<li>将构建后的目标文件放入构建目录的 bin 子目录<li>将 doc 目录 的内容以及 COPYRIGHT/README 安装到/usr/share/doc/cmake/</ul><h2 id="将目标文件放入构建目录的-bin-子目录">将目标文件放入构建目录的 bin 子目录</h2><p>每个目录下都要有一个CMakeLists.txt说明</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="n">root</span><span class="err">@</span><span class="n">localhost</span> <span class="n">cmake</span><span class="p">]</span><span class="err">#</span> <span class="n">tree</span>
<span class="p">.</span>
<span class="err">├──</span> <span class="n">build</span>
<span class="err">├──</span> <span class="n">CMakeLists</span><span class="p">.</span><span class="n">txt</span>
<span class="err">└──</span> <span class="n">src</span>
    <span class="err">├──</span> <span class="n">CMakeLists</span><span class="p">.</span><span class="n">txt</span>
    <span class="err">└──</span> <span class="n">main</span><span class="p">.</span><span class="n">cpp</span>
</pre></table></code></div></div><p>外层CMakeLists.txt</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">PROJECT</span><span class="p">(</span><span class="n">HELLO</span><span class="p">)</span>
<span class="n">ADD_SUBDIRECTORY</span><span class="p">(</span><span class="n">src</span> <span class="n">bin</span><span class="p">)</span>
</pre></table></code></div></div><p>src下的CMakeLists.txt</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">ADD_EXECUTABLE</span><span class="p">(</span><span class="n">hello</span> <span class="n">main</span><span class="p">.</span><span class="n">cpp</span><span class="p">)</span>
</pre></table></code></div></div><h3 id="add_subdirectory-指令">ADD_SUBDIRECTORY 指令</h3><p>ADD_SUBDIRECTORY(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</p><ul><li>这个指令用于<strong>向当前工程添加存放源文件的子目录</strong>，并可以指定中间二进制和目标二进制存放的位置<li>EXCLUDE_FROM_ALL函数是将写的目录从编译中排除，如程序中的example<li><p>ADD_SUBDIRECTORY(src bin)</p><p>将 src 子目录加入工程并指定编译输出(包含编译中间结果)路径为bin 目录</p><p>如果不进行 bin 目录的指定，那么编译结果(包括中间结果)都将存放在build/src 目录</p></ul><h3 id="更改二进制的保存路径">更改二进制的保存路径</h3><p>SET 指令重新定义 EXECUTABLE_OUTPUT_PATH 和 LIBRARY_OUTPUT_PATH 变量 来指定最终的目标二进制的位置</p><p>SET(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin)</p><p>SET(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib)</p><p>思考：加载哪个CMakeLists.txt当中</p><p>哪里要改变目标存放路径，就在哪里加入上述的定义，所以应该在src下的CMakeLists.txt下写</p><h1 id="安装">安装</h1><ul><li>一种是从代码编译后直接 make install 安装<li>一种是打包时的指定 目录安装。<ul><li>简单的可以这样指定目录：make install DESTDIR=/tmp/test<li>稍微复杂一点可以这样指定目录：./configure –prefix=/usr</ul></ul><h2 id="如何安装helloword">如何安装HelloWord</h2><p>使用CMAKE一个新的指令：INSTALL</p><p>INSTALL的安装可以包括：二进制、动态库、静态库以及文件、目录、脚本等</p><p>使用CMAKE一个新的变量：CMAKE_INSTALL_PREFIX</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="c1">// 目录树结构</span>
<span class="p">[</span><span class="n">root</span><span class="err">@</span><span class="n">localhost</span> <span class="n">cmake</span><span class="p">]</span><span class="err">#</span> <span class="n">tree</span>
<span class="p">.</span>
<span class="err">├──</span> <span class="n">build</span>
<span class="err">├──</span> <span class="n">CMakeLists</span><span class="p">.</span><span class="n">txt</span>
<span class="err">├──</span> <span class="n">COPYRIGHT</span>
<span class="err">├──</span> <span class="n">doc</span>
<span class="err">│  </span> <span class="err">└──</span> <span class="n">hello</span><span class="p">.</span><span class="n">txt</span>
<span class="err">├──</span> <span class="n">README</span>
<span class="err">├──</span> <span class="n">runhello</span><span class="p">.</span><span class="n">sh</span>
<span class="err">└──</span> <span class="n">src</span>
    <span class="err">├──</span> <span class="n">CMakeLists</span><span class="p">.</span><span class="n">txt</span>
    <span class="err">└──</span> <span class="n">main</span><span class="p">.</span><span class="n">cpp</span>

<span class="mi">3</span> <span class="n">directories</span><span class="p">,</span> <span class="mi">7</span> <span class="n">files</span>
</pre></table></code></div></div><h3 id="安装文件copyright和readme">安装文件COPYRIGHT和README</h3><p>INSTALL(FILES COPYRIGHT README DESTINATION share/doc/cmake/)</p><p>FILES：文件</p><p>DESTINATION：</p><p>1、写绝对路径</p><p>2、可以写相对路径，相对路径实际路径是：${CMAKE_INSTALL_PREFIX}/<DESTINATION 定义的路径=""></DESTINATION></p><p>CMAKE_INSTALL_PREFIX 默认是在 /usr/local/</p><p>cmake -DCMAKE_INSTALL_PREFIX=/usr 在cmake的时候指定CMAKE_INSTALL_PREFIX变量的路径</p><h3 id="安装脚本runhellosh">安装脚本runhello.sh</h3><p>PROGRAMS：非目标文件的可执行程序安装(比如脚本之类)</p><p>INSTALL(PROGRAMS runhello.sh DESTINATION bin)</p><p>说明：实际安装到的是 /usr/bin</p><h3 id="安装-doc-中的-hellotxt">安装 doc 中的 hello.txt</h3><ul><li>一、是通过在 doc 目录建立CMakeLists.txt ，通过install下的file<li><p>二、是直接在工程目录通过</p><p>INSTALL(DIRECTORY doc/ DESTINATION share/doc/cmake)</p></ul><p>DIRECTORY 后面连接的是所在 Source 目录的相对路径</p><p>注意：abc 和 abc/有很大的区别</p><p>目录名不以/结尾：这个目录将被安装为目标路径下的</p><p>目录名以/结尾：将这个目录中的内容安装到目标路径</p><h3 id="安装过程">安装过程</h3><p>cmake ..</p><p>make</p><p>make install</p><h1 id="静态库和动态库的构建">静态库和动态库的构建</h1><p>任务：</p><p>１，建立一个静态库和动态库，提供 HelloFunc 函数供其他程序编程使用，HelloFunc 向终端输出 Hello World 字符串。</p><p>２，安装头文件与共享库。</p><p>静态库和动态库的区别</p><ul><li>静态库的扩展名一般为“.a”或“.lib”；动态库的扩展名一般为“.so”或“.dll”。<li>静态库在编译时会直接整合到目标程序中，编译成功的可执行文件可独立运行<li>动态库在编译时不会放到连接的目标程序中，即可执行文件无法单独运行。</ul><h2 id="构建实例">构建实例</h2><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="n">root</span><span class="err">@</span><span class="n">localhost</span> <span class="n">cmake2</span><span class="p">]</span><span class="err">#</span> <span class="n">tree</span>
<span class="p">.</span>
<span class="err">├──</span> <span class="n">build</span>
<span class="err">├──</span> <span class="n">CMakeLists</span><span class="p">.</span><span class="n">txt</span>
<span class="err">└──</span> <span class="n">lib</span>
    <span class="err">├──</span> <span class="n">CMakeLists</span><span class="p">.</span><span class="n">txt</span>
    <span class="err">├──</span> <span class="n">hello</span><span class="p">.</span><span class="n">cpp</span>
    <span class="err">└──</span> <span class="n">hello</span><span class="p">.</span><span class="n">h</span>
</pre></table></code></div></div><p>hello.h中的内容</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="cp">#ifndef HELLO_H
#define Hello_H
</span>
<span class="kt">void</span> <span class="nf">HelloFunc</span><span class="p">();</span>

<span class="cp">#endif
</span></pre></table></code></div></div><p>hello.cpp中的内容</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">"hello.h"</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="kt">void</span> <span class="nf">HelloFunc</span><span class="p">(){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello World"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>项目中的cmake内容</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">PROJECT</span><span class="p">(</span><span class="n">HELLO</span><span class="p">)</span>
<span class="n">ADD_SUBDIRECTORY</span><span class="p">(</span><span class="n">lib</span> <span class="n">bin</span><span class="p">)</span>
</pre></table></code></div></div><p>lib中CMakeLists.txt中的内容</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">SET</span><span class="p">(</span><span class="n">LIBHELLO_SRC</span> <span class="n">hello</span><span class="p">.</span><span class="n">cpp</span><span class="p">)</span>
<span class="n">ADD_LIBRARY</span><span class="p">(</span><span class="n">hello</span> <span class="n">SHARED</span> <span class="err">$</span><span class="p">{</span><span class="n">LIBHELLO_SRC</span><span class="p">})</span>
</pre></table></code></div></div><h3 id="add_library">ADD_LIBRARY</h3><p>ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC})</p><ul><li>hello：就是正常的库名，生成的名字前面会加上lib，最终产生的文件是libhello.so<li>SHARED，动态库 STATIC，静态库<li>${LIBHELLO_SRC} ：源文件</ul><h3 id="同时构建静态和动态库">同时构建静态和动态库</h3><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="c1">// 如果用这种方式，只会构建一个动态库，不会构建出静态库，虽然静态库的后缀是.a</span>
<span class="n">ADD_LIBRARY</span><span class="p">(</span><span class="n">hello</span> <span class="n">SHARED</span> <span class="err">$</span><span class="p">{</span><span class="n">LIBHELLO_SRC</span><span class="p">})</span>
<span class="n">ADD_LIBRARY</span><span class="p">(</span><span class="n">hello</span> <span class="n">STATIC</span> <span class="err">$</span><span class="p">{</span><span class="n">LIBHELLO_SRC</span><span class="p">})</span>

<span class="c1">// 修改静态库的名字，这样是可以的，但是我们往往希望他们的名字是相同的，只是后缀不同而已</span>
<span class="n">ADD_LIBRARY</span><span class="p">(</span><span class="n">hello</span> <span class="n">SHARED</span> <span class="err">$</span><span class="p">{</span><span class="n">LIBHELLO_SRC</span><span class="p">})</span>
<span class="n">ADD_LIBRARY</span><span class="p">(</span><span class="n">hello_static</span> <span class="n">STATIC</span> <span class="err">$</span><span class="p">{</span><span class="n">LIBHELLO_SRC</span><span class="p">})</span>
</pre></table></code></div></div><h3 id="set_target_properties">SET_TARGET_PROPERTIES</h3><p>这条指令可以用来设置输出的名称，对于动态库，还可以用来指定动态库版本和 API 版本</p><p>同时构建静态和动态库</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="n">SET</span><span class="p">(</span><span class="n">LIBHELLO_SRC</span> <span class="n">hello</span><span class="p">.</span><span class="n">cpp</span><span class="p">)</span>

<span class="n">ADD_LIBRARY</span><span class="p">(</span><span class="n">hello_static</span> <span class="n">STATIC</span> <span class="err">$</span><span class="p">{</span><span class="n">LIBHELLO_SRC</span><span class="p">})</span>

<span class="c1">//对hello_static的重名为hello</span>
<span class="n">SET_TARGET_PROPERTIES</span><span class="p">(</span><span class="n">hello_static</span> <span class="n">PROPERTIES</span>  <span class="n">OUTPUT_NAME</span> <span class="s">"hello"</span><span class="p">)</span>
<span class="c1">//cmake 在构建一个新的target 时，会尝试清理掉其他使用这个名字的库，因为，在构建 libhello.so 时， 就会清理掉 libhello.a</span>
<span class="n">SET_TARGET_PROPERTIES</span><span class="p">(</span><span class="n">hello_static</span> <span class="n">PROPERTIES</span> <span class="n">CLEAN_DIRECT_OUTPUT</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">ADD_LIBRARY</span><span class="p">(</span><span class="n">hello</span> <span class="n">SHARED</span> <span class="err">$</span><span class="p">{</span><span class="n">LIBHELLO_SRC</span><span class="p">})</span>

<span class="n">SET_TARGET_PROPERTIES</span><span class="p">(</span><span class="n">hello</span> <span class="n">PROPERTIES</span>  <span class="n">OUTPUT_NAME</span> <span class="s">"hello"</span><span class="p">)</span>
<span class="n">SET_TARGET_PROPERTIES</span><span class="p">(</span><span class="n">hello</span> <span class="n">PROPERTIES</span> <span class="n">CLEAN_DIRECT_OUTPUT</span> <span class="mi">1</span><span class="p">)</span>

</pre></table></code></div></div><h3 id="动态库的版本号">动态库的版本号</h3><p>一般动态库都有一个版本号的关联</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">libhello</span><span class="p">.</span><span class="n">so</span><span class="mf">.1.2</span>
<span class="n">libhello</span><span class="p">.</span><span class="n">so</span> <span class="o">-&gt;</span><span class="n">libhello</span><span class="p">.</span><span class="n">so</span><span class="mf">.1</span>
<span class="n">libhello</span><span class="p">.</span><span class="n">so</span><span class="mf">.1</span><span class="o">-&gt;</span><span class="n">libhello</span><span class="p">.</span><span class="n">so</span><span class="mf">.1.2</span>
</pre></table></code></div></div><p>CMakeLists.txt 插入如下</p><p><code class="language-plaintext highlighter-rouge">SET_TARGET_PROPERTIES(hello PROPERTIES VERSION 1.2 SOVERSION 1)</code></p><p>VERSION 指代动态库版本，SOVERSION 指代 API 版本。</p><h3 id="安装共享库和头文件">安装共享库和头文件</h3><p>本例中我们将 hello 的共享库安装到fix>/lib目录，</prefix></p><p>将 hello.h 安装到fix>/include/hello 目录</prefix></p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="c1">//文件放到该目录下</span>
<span class="n">INSTALL</span><span class="p">(</span><span class="n">FILES</span> <span class="n">hello</span><span class="p">.</span><span class="n">h</span> <span class="n">DESTINATION</span> <span class="n">include</span><span class="o">/</span><span class="n">hello</span><span class="p">)</span>

<span class="c1">//二进制，静态库，动态库安装都用TARGETS</span>
<span class="c1">//ARCHIVE 特指静态库，LIBRARY 特指动态库，RUNTIME 特指可执行目标二进制。</span>
<span class="n">INSTALL</span><span class="p">(</span><span class="n">TARGETS</span> <span class="n">hello</span> <span class="n">hello_static</span> <span class="n">LIBRARY</span> <span class="n">DESTINATION</span> <span class="n">lib</span> <span class="n">ARCHIVE</span> <span class="n">DESTINATION</span> <span class="n">lib</span><span class="p">)</span>
</pre></table></code></div></div><p>注意：</p><p>安装的时候，指定一下路径，放到系统下</p><p><code class="language-plaintext highlighter-rouge">cmake -DCMAKE_INSTALL_PREFIX=/usr ..</code></p><h3 id="使用外部共享库和头文件">使用外部共享库和头文件</h3><p>准备工作，新建一个目录来使用外部共享库和头文件</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="n">root</span><span class="err">@</span><span class="n">MiWiFi</span><span class="o">-</span><span class="n">R4CM</span><span class="o">-</span><span class="n">srv</span> <span class="n">cmake3</span><span class="p">]</span><span class="err">#</span> <span class="n">tree</span>
<span class="p">.</span>
<span class="err">├──</span> <span class="n">build</span>
<span class="err">├──</span> <span class="n">CMakeLists</span><span class="p">.</span><span class="n">txt</span>
<span class="err">└──</span> <span class="n">src</span>
    <span class="err">├──</span> <span class="n">CMakeLists</span><span class="p">.</span><span class="n">txt</span>
    <span class="err">└──</span> <span class="n">main</span><span class="p">.</span><span class="n">cpp</span>
</pre></table></code></div></div><p>main.cpp</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;hello.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
	<span class="n">HelloFunc</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="解决make后头文件找不到的问题">解决：make后头文件找不到的问题</h3><p>PS：include &lt;hello/hello.h&gt; 这样include是可以，这么做的话，就没啥好讲的了</p><p>关键字：INCLUDE_DIRECTORIES 这条指令可以用来向工程添加多个特定的头文件搜索路径，路径之间用空格分割</p><p>在CMakeLists.txt中加入头文件搜索路径</p><p>INCLUDE_DIRECTORIES(/usr/include/hello)</p><p>感谢：</p><p>网友：zcc720的提醒</p><h3 id="解决找到引用的函数问题">解决：找到引用的函数问题</h3><p>报错信息：undefined reference to `HelloFunc()’</p><p>关键字：LINK_DIRECTORIES 添加非标准的共享库搜索路径</p><p>指定第三方库所在路径，LINK_DIRECTORIES(/home/myproject/libs)</p><p>关键字：TARGET_LINK_LIBRARIES 添加需要链接的共享库</p><p>TARGET_LINK_LIBRARIES的时候，只需要给出动态链接库的名字就行了。</p><p>在CMakeLists.txt中插入链接共享库，主要要插在executable的后面</p><p>查看main的链接情况</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="n">root</span><span class="err">@</span><span class="n">MiWiFi</span><span class="o">-</span><span class="n">R4CM</span><span class="o">-</span><span class="n">srv</span> <span class="n">bin</span><span class="p">]</span><span class="err">#</span> <span class="n">ldd</span> <span class="n">main</span>
	<span class="n">linux</span><span class="o">-</span><span class="n">vdso</span><span class="p">.</span><span class="n">so</span><span class="mf">.1</span> <span class="o">=&gt;</span>  <span class="p">(</span><span class="mh">0x00007ffedfda4000</span><span class="p">)</span>
	<span class="n">libhello</span><span class="p">.</span><span class="n">so</span> <span class="o">=&gt;</span> <span class="o">/</span><span class="n">lib64</span><span class="o">/</span><span class="n">libhello</span><span class="p">.</span><span class="n">so</span> <span class="p">(</span><span class="mh">0x00007f41c0d8f000</span><span class="p">)</span>
	<span class="n">libstdc</span><span class="o">++</span><span class="p">.</span><span class="n">so</span><span class="mf">.6</span> <span class="o">=&gt;</span> <span class="o">/</span><span class="n">lib64</span><span class="o">/</span><span class="n">libstdc</span><span class="o">++</span><span class="p">.</span><span class="n">so</span><span class="mf">.6</span> <span class="p">(</span><span class="mh">0x00007f41c0874000</span><span class="p">)</span>
	<span class="n">libm</span><span class="p">.</span><span class="n">so</span><span class="mf">.6</span> <span class="o">=&gt;</span> <span class="o">/</span><span class="n">lib64</span><span class="o">/</span><span class="n">libm</span><span class="p">.</span><span class="n">so</span><span class="mf">.6</span> <span class="p">(</span><span class="mh">0x00007f41c0572000</span><span class="p">)</span>
	<span class="n">libgcc_s</span><span class="p">.</span><span class="n">so</span><span class="mf">.1</span> <span class="o">=&gt;</span> <span class="o">/</span><span class="n">lib64</span><span class="o">/</span><span class="n">libgcc_s</span><span class="p">.</span><span class="n">so</span><span class="mf">.1</span> <span class="p">(</span><span class="mh">0x00007f41c035c000</span><span class="p">)</span>
	<span class="n">libc</span><span class="p">.</span><span class="n">so</span><span class="mf">.6</span> <span class="o">=&gt;</span> <span class="o">/</span><span class="n">lib64</span><span class="o">/</span><span class="n">libc</span><span class="p">.</span><span class="n">so</span><span class="mf">.6</span> <span class="p">(</span><span class="mh">0x00007f41bff8e000</span><span class="p">)</span>
	<span class="o">/</span><span class="n">lib64</span><span class="o">/</span><span class="n">ld</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">x86</span><span class="o">-</span><span class="mf">64.</span><span class="n">so</span><span class="mf">.2</span> <span class="p">(</span><span class="mh">0x00007f41c0b7c000</span><span class="p">)</span>
</pre></table></code></div></div><p>链接静态库</p><p><code class="language-plaintext highlighter-rouge">TARGET_LINK_LIBRARIES(main libhello.a)</code></p><h3 id="特殊的环境变量-cmake_include_path-和-cmake_library_path">特殊的环境变量 CMAKE_INCLUDE_PATH 和 CMAKE_LIBRARY_PATH</h3><p>注意：这两个是环境变量而不是 cmake 变量，可以在linux的bash中进行设置</p><p>我们上面例子中使用了绝对路径INCLUDE_DIRECTORIES(/usr/include/hello)来指明include路径的位置</p><p>我们还可以使用另外一种方式，使用环境变量export CMAKE_INCLUDE_PATH=/usr/include/hello</p><p>补充：生产debug版本的方法： cmake .. -DCMAKE_BUILD_TYPE=debug</p><h1 id="cmake变量"><a href="https://www.cnblogs.com/narjaja/p/9533174.html">CMake–变量</a></h1><h3 id="1一般变量">1.一般变量</h3><h3 id="1cmake变量引用的方式">1)CMake变量引用的方式</h3><p>使用${}进行变量的引用。例如：</p><div lang="bash" class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">${</span><span class="nv">PROJECT_NAME</span><span class="k">}</span> <span class="c">#返回项目名称</span>
</pre></table></code></div></div><p>在 IF 等语句中,是直接使用变量名而不通过${}取值。</p><h3 id="2cmake自定义变量的方式">2)cmake自定义变量的方式</h3><p>cmake变量定义的方式有两种：隐式定义和显式定义。</p><p><em>隐式定义</em></p><p>前面举了一个隐式定义的例子，就是PROJECT指令，他会隐式的定义_BINARY_DIR和_SOURCE_DIR两个变量。</p><p><em>显示定义</em></p><p>显式定义的例子我们前面也提到了,使用 SET 指令,就可以构建一个自定义变量了。</p><p>比如:</p><div lang="scss" class="language-scss highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nt">SET</span><span class="o">(</span><span class="nt">HELLO_SRC</span> <span class="nt">main</span><span class="nc">.c</span><span class="o">)</span>
</pre></table></code></div></div><p>就可以通过${HELLO_SRC}来引用这个自定义变量(main.c)了.</p><h3 id="2-环境变量">2. 环境变量</h3><h4 id="1调用环境变量的方式">1)调用环境变量的方式</h4><p>使用 $ENV{NAME} 指令就可以调用系统的环境变量了。 比如</p><div lang="bash" class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>MESSAGE<span class="o">(</span>STATUS “HOME <span class="nb">dir</span>: <span class="nv">$ENV</span><span class="o">{</span>HOME<span class="o">}</span>”<span class="o">)</span>
</pre></table></code></div></div><h4 id="2设置环境变量的方式">2)设置环境变量的方式</h4><div lang="scss" class="language-scss highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nt">SET</span><span class="o">(</span><span class="nt">ENV</span><span class="p">{</span> <span class="err">变量名</span> <span class="p">}</span> <span class="err">值</span> <span class="o">)</span>
</pre></table></code></div></div><h3 id="3-cmake常用变量">3. CMake常用变量</h3><div class="table-wrapper"><table><thead><tr><th>变量名<th style="text-align: center">变量说明<tbody><tr><td>PROJECT_NAME<td style="text-align: center">返回通过PROJECT指令定义的项目名称<tr><td>PROJECT_SOURCE_DIR<td style="text-align: center">CMake源码地址，即cmake命令后指定的地址<tr><td>PROJECT_BINARY_DIR<td style="text-align: center">运行cmake命令的目录,通常是PROJECT_SOURCE_DIR下的build目录<tr><td>CMAKE_MODULE_PATH<td style="text-align: center">定义自己的cmake模块所在的路径<tr><td>CMAKE_CURRENT_SOURCE_DIR<td style="text-align: center">当前处理的CMakeLists.txt所在的路径<tr><td>CMAKE_CURRENT_LIST_DIR<td style="text-align: center">当前文件夹路径<tr><td>CMAKE_CURRENT_LIST_FILE<td style="text-align: center">输出调用这个变量的CMakeLists.txt的完整路径<tr><td>CMAKE_CURRENT_LIST_LINE<td style="text-align: center">输出这个变量所在的行<tr><td>CMAKE_RUNTIME_OUTPUT_DIRECTORY<td style="text-align: center">生成可执行文件路径<tr><td>CMAKE_LIBRARY_OUTPUT_DIRECTORY<td style="text-align: center">生成库的文件夹路径<tr><td>CMAKE_BUILD_TYPE<td style="text-align: center">指定基于make的产生器的构建类型（Release，Debug）<tr><td>CMAKE_C_FLAGS<td style="text-align: center"><em>.C文件编译选项，如 *-std=c99 -O3 -march=native</em><tr><td>CMAKE_CXX_FLAGS<td style="text-align: center"><em>.CPP文件编译选项，如 *-std=c++11 -O3 -march=native</em><tr><td>CMAKE_CURRENT_BINARY_DIR<td style="text-align: center">target编译目录<tr><td>CMAKE_INCLUDE_PATH<td style="text-align: center">环境变量,非cmake变量<tr><td>CMAKE_LIBRARY_PATH<td style="text-align: center">环境变量<tr><td>CMAKE_STATIC_LIBRARY_PREFIX<td style="text-align: center">静态库前缀, Linux下默认为lib<tr><td>CMAKE_STATIC_LIBRARY_SUFFIX<td style="text-align: center">静态库后缀，Linux下默认为.a<tr><td>CMAKE_SHARED_LIBRARY_PREFIX<td style="text-align: center">动态库前缀，Linux下默认为lib<tr><td>CMAKE_SHARED_LIBRARY_SUFFIX<td style="text-align: center">动态库后缀，Linux下默认为.so<tr><td>BUILD_SHARED_LIBS<td style="text-align: center">如果为ON，则add_library默认创建共享库<tr><td>CMAKE_INSTALL_PREFIX<td style="text-align: center">配置安装路径，默认为/usr/local<tr><td>CMAKE_ABSOLUTE_DESTINATION_FILES<td style="text-align: center">安装文件列表时使用ABSOLUTE DESTINATION 路径<tr><td>CMAKE_AUTOMOC_RELAXED_MODE<td style="text-align: center">在严格和宽松的automoc模式间切换<tr><td>CMAKE_BACKWARDS_COMPATIBILITY<td style="text-align: center">构建工程所需要的CMake版本<tr><td>CMAKE_COLOR_MAKEFILE<td style="text-align: center">开启时，使用Makefile产生器会产生彩色输出<tr><td>CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS<td style="text-align: center">用来控制IF ELSE语句的书写方式</table></div><h3 id="4系统信息">4.系统信息</h3><p>1,CMAKE_MAJOR_VERSION , CMAKE 主版本号,比如 2.4.6 中的 2 2,CMAKE_MINOR_VERSION , CMAKE 次版本号,比如 2.4.6 中的 4 3,CMAKE_PATCH_VERSION , CMAKE 补丁等级,比如 2.4.6 中的 6 4,CMAKE_SYSTEM ,系统名称,比如 Linux-2.6.22 5,CMAKE_SYSTEM_NAME ,不包含版本的系统名,比如 Linux 6,CMAKE_SYSTEM_VERSION ,系统版本,比如 2.6.22 7,CMAKE_SYSTEM_PROCESSOR ,处理器名称,比如 i686. 8,UNIX ,在所有的类 UNIX 平台为 TRUE ,包括 OS X 和 cygwin 9,WIN32 ,在所有的 win32 平台为 TRUE ,包括 cygwin</p><h4 id="5主要的开关选项">5.主要的开关选项:</h4><p>1 , CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS ,用来控制 IF ELSE 语句的书写方式,在下一节语法部分会讲到。</p><p>2 , BUILD_SHARED_LIBS 这个开关用来控制默认的库编译方式,如果不进行设置,使用 ADD_LIBRARY 并没有指定库类型的情况下,默认编译生成的库都是静态库。</p><p>如果 SET(BUILD_SHARED_LIBS ON) 后,默认生成的为动态库。</p><p>3, CMAKE_C_FLAGS</p><p>设置 C 编译选项,也可以通过指令 ADD_DEFINITIONS() 添加。</p><p>4 , CMAKE_CXX_FLAGS</p><p>设置 C++ 编译选项,也可以通过指令 ADD_DEFINITIONS() 添加。</p><h1 id="cmake的generator详解">cmake的generator详解</h1><p><strong>前言：</strong>cmake会通过cmakelist.txt文件，生成适用于不同项目类型的makefile文件，然后makefile文件被不同的编译器使用进行编译，考虑到C/C++的开发环境之多，有非常多的种类的项目开发环境，但是cmake基本上都考虑到了，这里做一个小的汇总。</p><p><strong>CMake支持下列generator：</strong></p><ul><li><p>Visual Studio 6: 生成Visual Studio 6 工程文件。-</p><li><p>Visual Studio 7: 生成Visual Studio .NET 2002 工程文件。</p><li><p>Visual Studio 10: 生成Visual Studio 10(2010) 工程文件。</p><li><p>Visual Studio 10 Win64会生成x64平台的工程;Visual Studio 10 IA64是Itanium平台。</p><li><p>Visual Studio 11: 生成Visual Studio 11(2012) 工程文件。</p><li><p>Visual Studio 11 Win64会生成x64平台的工程;Visual Studio 11 ARM是ARM平台</p><li><p>Visual Studio 7 .NET 2003: 生成Visual Studio 7 .NET 2003 工程文件。</p><li><p>Visual Studio 8 2005: 生成 Visual Studio 8 2005工程文件。</p><li><p>Visual Studio 8 2005 Win64会生成x64平台的工程。</p><li><p>Visual Studio 9 2008: 生成 Visual Studio 9 2008工程文件。</p><li><p>Visual Studio 9 2008 Win64会生成x64平台的工程;Visual Studio 9 2008 IA64是Itanium平台。</p><li><p>Borland Makefiles: 生成Borland makefile。</p><li><p>NMake Makefiles: 生成NMake makefile。</p><li><p>NMake Makefiles JOM: 生成JOM makefile。</p><li><p>Watcom WMake: 生成Watcom WMake makefiles。</p><li><p>MSYS Makefiles: 生成MSYS makefile。 生成的makefile用 /bin/sh作为它的shell。在运行CMake的机器上需要安装msys</p><li><p>MinGW Makefiles: 生成供mingw32-make使用的make file。 生成的makefile使用cmd.exe作为它的shell。生成它们不需要msys或者unix shell。</p><li><p>Unix Makefiles: 生成标准的UNIX makefile。 在构建树上生成分层的UNIX makefile。任何标准的UNIX风格的make程序都可以通过默认的make目标构建工程。生成的makefile也提供了install目标。</p><li><p>Ninja：生成.ninja工程。</p><li><p>Xcode：生成Xcode工程。</p><li><p>CodeBlocks - MinGW Makefiles：生成CodeBlocks工程。</p><p>在顶层目录以及每层子目录下为CodeBlocks生成工程文件，生成的CMakeList.txt的特点是都包含一个PROJECT()调用。除此之外还会在构建树上生成一套层次性的makefile。通过默认的make目标，正确的make程序可以构建这个工程。makefile还提供了install目标。</p><li><p>CodeBlocks - NMake Makefiles：生成CodeBlocks工程。</p><p>在顶层目录以及每层子目录下为CodeBlocks生成工程文件，生成的CMakeList.txt的特点是都包含一个PROJECT()调用。除此之外还会在构建树上生成一套层次性的makefile。通过默认的make目标，正确的make程序可以构建这个工程。makefile还提供了install目标。</p><li><p>CodeBlocks - Ninja：生成CodeBlocks工程。</p><li><p>CodeBlocks - Unix Makefiles：生成CodeBlocks工程。</p></ul><p>在顶层目录以及每层子目录下为CodeBlocks生成工程文件，生成的CMakeList.txt的特点是都包含一个PROJECT()调用。除此之外还会在构建树上生成一套层次性的makefile。通过默认的make目标，正确的make程序可以构建这个工程。makefile还提供了install目标。</p><ul><li><p>Eclipse CDT4 - MinGW Makefiles: 生成Eclipse CDT 4.0 工程文件。</p><p>在顶层目录下为Eclipse生成工程文件。在运行源码外构建时，一个连接到顶层源码路径的资源文件会被创建。除此之外还会在构建树上生成一套层次性的makefile。通过默认的make目标，正确的make程序可以构建这个工程。makefile还提供了install目标。</p><li><p>Eclipse CDT4 - NMake Makefiles: 生成Eclipse CDT 4.0 工程文件。</p><p>在顶层目录下为Eclipse生成工程文件。在运行源码外构建时，一个连接到顶层源码路径的资源文件会被创建。除此之外还会在构建树上生成一套层次性的makefile。通过默认的make目标，正确的make程序可以构建这个工程。makefile还提供了install目标。</p><li><p>Eclipse CDT4 - NMake Makefiles：生成Eclipse CDT 4.0 工程文件。</p><li><p>Eclipse CDT4 - Ninja：生成Eclipse CDT 4.0 工程文件。</p><li><p>Eclipse CDT4 - Unix Makefiles: 生成Eclipse CDT 4.0 工程文件。</p><p>在顶层目录下为Eclipse生成工程文件。在运行源码外构建时，一个连接到顶层源码路径的资源文件会被创建。除此之外还会在构建树上生成一套层次性的makefile。通过默认的make目标，正确的make程序可以构建这个工程。makefile还提供了install目标。</p><li><p>KDevelop3: 生成KDevelop 3工程文件。</p><li><p>KDevelop3 - Unix Makefiles: 生成KDevelop 3工程文件。</p><li><p>Sublime Text 2 - MinGW Makefiles: 生成Sublime Text 2工程文件。</p><li><p>Sublime Text 2 - NMake Makefiles: 生成Sublime Text 2工程文件。</p><li><p>Sublime Text 2 - Ninja: 生成Sublime Text 2工程文件。</p><li><p>Sublime Text 2 - Unix Makefiles: 生成Sublime Text 2工程文件。</p></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E5%B7%A5%E5%85%B7/'>工具</a>, <a href='/categories/cmake/'>CMake</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cmake/" class="post-tag no-text-decoration" >CMake</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=CMake笔记 - Calm's blog&url=http://calm-peng.github.io/posts/CMake%E7%AC%94%E8%AE%B0/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=CMake笔记 - Calm's blog&u=http://calm-peng.github.io/posts/CMake%E7%AC%94%E8%AE%B0/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=CMake笔记 - Calm's blog&url=http://calm-peng.github.io/posts/CMake%E7%AC%94%E8%AE%B0/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/C++%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/">C++回调函数</a><li><a href="/posts/%E5%AE%8F%E5%AE%9A%E4%B9%89-define/">C/C++/中宏特殊字符的含义及用法总结</a><li><a href="/posts/CMake%E7%AC%94%E8%AE%B0/">CMake笔记</a><li><a href="/posts/CMake-%E5%9F%BA%E6%9C%AC%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95-CMakeLists.txt/">CMake基本常用语法CMakeLists.txt</a><li><a href="/posts/C-C++/">C/C++</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/c-c/">C/C++</a> <a class="post-tag" href="/tags/cmake/">CMake</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/CMake-%E5%9F%BA%E6%9C%AC%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95-CMakeLists.txt/"><div class="card-body"> <span class="timeago small" > Mar 14, 2022 <i class="unloaded">2022-03-14T17:57:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>CMake基本常用语法CMakeLists.txt</h3><div class="text-muted small"><p> Hello, World cmake_minimum_required(VERSION 3.5) # 指定CMake的版本 project(hello-world) # 项目名称 add_executable(hello helloworld.cpp) # 创建一个可执行程序 基本语法 文件编码-Encoding 官方说明文档:文件编码 在3.0以下的版本，CMake文件必须使...</p></div></div></a></div><div class="card"> <a href="/posts/STL%E5%AE%B9%E5%99%A8/"><div class="card-body"> <span class="timeago small" > Oct 29, 2022 <i class="unloaded">2022-10-29T20:40:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>STL容器</h3><div class="text-muted small"><p> STL容器 Vector 基本使用 (1)头文件 #include. (2)创建vector对象，vector vec; (3)尾部插入数字：vec.push_back(a) (4)使用下标访问元素，cout«vec[0]«endl;记住下标是从0开始的。 (5)使用迭代器访问元素. 1 2 3 vector&lt;int&gt;::iterator it; for(it=v...</p></div></div></a></div><div class="card"> <a href="/posts/C++%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/"><div class="card-body"> <span class="timeago small" > Jun 30, 2022 <i class="unloaded">2022-06-30T15:38:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++回调函数</h3><div class="text-muted small"><p> C++回调函数 1、什么是回调函数 回调函数本质上也是普通函数，只是调用机制有所区别——首先通过传参的形式将该函数的地址传递给其他函数，然后在其他函数中通过函数指针调用该函数。在其他函数中通过函数指针调用该函数的过程称为回调，而作为被调用的该函数则被称为回调函数。有人可能会疑惑何必多此一举，直接在其他函数中调用该函数就好，为何一定要通过指针中转。 2、为什么需要回调函数 这就不得不提到项...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/_tmain()%E5%92%8Cmain()/" class="btn btn-outline-primary" prompt="Older"><p>_tmain()和main()</p></a> <a href="/posts/%E5%AE%8F%E5%AE%9A%E4%B9%89-define/" class="btn btn-outline-primary" prompt="Newer"><p>C/C++/中宏特殊字符的含义及用法总结</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://twitter.com/username">calm-peng</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/c-c/">C/C++</a> <a class="post-tag" href="/tags/cmake/">CMake</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="http://calm-peng.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script async src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script>
