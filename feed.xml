<feed xmlns="http://www.w3.org/2005/Atom"> <id>http://calm-peng.github.io/</id><title>Calm's blog</title><subtitle>A minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation.</subtitle> <updated>2023-04-16T20:43:44+08:00</updated> <author> <name>calm-peng</name> <uri>http://calm-peng.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="http://calm-peng.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="zh-CN" href="http://calm-peng.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator> <rights> © 2023 calm-peng </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>STL容器</title><link href="http://calm-peng.github.io/posts/STL%E5%AE%B9%E5%99%A8/" rel="alternate" type="text/html" title="STL容器" /><published>2022-10-29T20:40:00+08:00</published> <updated>2022-10-29T20:40:00+08:00</updated> <id>http://calm-peng.github.io/posts/STL%E5%AE%B9%E5%99%A8/</id> <content src="http://calm-peng.github.io/posts/STL%E5%AE%B9%E5%99%A8/" /> <author> <name>calm-peng</name> </author> <category term="语言" /> <category term="C\C++" /> <summary> STL容器 Vector 基本使用 (1)头文件 #include. (2)创建vector对象，vector vec; (3)尾部插入数字：vec.push_back(a) (4)使用下标访问元素，cout«vec[0]«endl;记住下标是从0开始的。 (5)使用迭代器访问元素. vector&amp;lt;int&amp;gt;::iterator it; for(it=vec.begin();it!=vec.end();it++) cout&amp;lt;&amp;lt;*it&amp;lt;&amp;lt;endl; (6)插入元素： vec.insert(vec.begin()+i,a);在第i+1个元素前面插入a; (7)删除元素：vec.erase(vec.begin()+2);删除第3个元素 vec.erase(vec.begin()+i,vec.end()+j);删除区间[i,j-1];... </summary> </entry> <entry><title>C++回调函数</title><link href="http://calm-peng.github.io/posts/C++%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/" rel="alternate" type="text/html" title="C++回调函数" /><published>2022-06-30T15:38:00+08:00</published> <updated>2023-04-16T20:33:16+08:00</updated> <id>http://calm-peng.github.io/posts/C++%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</id> <content src="http://calm-peng.github.io/posts/C++%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/" /> <author> <name>calm-peng</name> </author> <category term="语言" /> <category term="C\C++" /> <summary> C++回调函数 1、什么是回调函数 回调函数本质上也是普通函数，只是调用机制有所区别——首先通过传参的形式将该函数的地址传递给其他函数，然后在其他函数中通过函数指针调用该函数。在其他函数中通过函数指针调用该函数的过程称为回调，而作为被调用的该函数则被称为回调函数。有人可能会疑惑何必多此一举，直接在其他函数中调用该函数就好，为何一定要通过指针中转。 2、为什么需要回调函数 这就不得不提到项目联合开发带来的必然后果——接口的兼容性问题。举个超级简单的例子：程序员小A和程序员小B联合开发一个项目，要求小A开发的函数必须为小B开发的函数提供灵活可用的接口。 假如小A小B是好朋友，他们天天在一起，而且也不考虑开发效率问题，那就串行方式一起开发好了。如下例所示，在同一个文件中，小A先负责开发Add()函数，小B后负责开发add()函数，小A需要调用小B的函数，即小A为小B提供了一个接口，通过... </summary> </entry> <entry><title>C/C++/中宏特殊字符的含义及用法总结</title><link href="http://calm-peng.github.io/posts/%E5%AE%8F%E5%AE%9A%E4%B9%89-define/" rel="alternate" type="text/html" title="C/C++/中宏特殊字符的含义及用法总结" /><published>2022-04-14T15:35:00+08:00</published> <updated>2022-07-14T17:40:00+08:00</updated> <id>http://calm-peng.github.io/posts/%E5%AE%8F%E5%AE%9A%E4%B9%89-define/</id> <content src="http://calm-peng.github.io/posts/%E5%AE%8F%E5%AE%9A%E4%B9%89-define/" /> <author> <name>calm-peng</name> </author> <category term="语言" /> <category term="C\C++" /> <summary> 在C／C＋＋中，宏定义是由define完成的，宏定义中有几种常见的特殊字符需要我们了解，常用的特殊字符有以下几种： #：在宏展开的时候会将#后面的参数替换成字符串； 字符串化 ##:将前后两个的单词拼接在一起； 连接化 #@:将值序列变为一个字符； 字符化 :将两行连接起来。行连接化 我们可以使用这些特殊的字符做一些简单的测试例子： 1.# 测试 测试代码如下： #include &amp;lt;iostream&amp;gt; #include &amp;lt;stdlib.h&amp;gt; using namespace std; #define PRINT(name) #name int main(int argc, char* argv[]) { char* ch1= PRINT(南抒一梦); std::cout &amp;lt;&amp;lt; ch1 &amp;lt;&amp;lt; std... </summary> </entry> <entry><title>CMake笔记</title><link href="http://calm-peng.github.io/posts/CMake%E7%AC%94%E8%AE%B0/" rel="alternate" type="text/html" title="CMake笔记" /><published>2022-04-14T12:53:00+08:00</published> <updated>2022-04-14T13:17:32+08:00</updated> <id>http://calm-peng.github.io/posts/CMake%E7%AC%94%E8%AE%B0/</id> <content src="http://calm-peng.github.io/posts/CMake%E7%AC%94%E8%AE%B0/" /> <author> <name>calm-peng</name> </author> <category term="工具" /> <category term="CMake" /> <summary> 说明 cmake的定义是什么 ？—–高级编译配置工具 当多个人用不同的语言或者编译器开发一个项目，最终要输出一个可执行文件或者共享库（dll，so等等）这时候神器就出现了—–CMake！ 所有操作都是通过编译CMakeLists.txt来完成的—简单 官 方网站是 www.cmake.org，可以通过访问官方网站获得更多关于 cmake 的信息 学习CMake的目的，为将来处理大型的C/C++/JAVA项目做准备 CMake安装 1、绝大多数的linux系统已经安装了CMake 2、Windows或某些没有安装过的linux系统，去http://www.cmake.org/HTML/Download.html 可以下载安装 CMake一个HelloWord 1、步骤一，写一个HelloWord #main.cpp #include &amp;lt;iostream&amp;... </summary> </entry> <entry><title>_tmain()和main()</title><link href="http://calm-peng.github.io/posts/_tmain()%E5%92%8Cmain()/" rel="alternate" type="text/html" title="_tmain()和main()" /><published>2022-04-13T15:30:00+08:00</published> <updated>2022-04-13T15:30:00+08:00</updated> <id>http://calm-peng.github.io/posts/_tmain()%E5%92%8Cmain()/</id> <content src="http://calm-peng.github.io/posts/_tmain()%E5%92%8Cmain()/" /> <author> <name>calm-peng</name> </author> <category term="语言" /> <category term="C\C++" /> <summary> 首先，这个_tmain()是为了支持unicode所使用的main一个别名而已。 既然是别名，应该有宏定义过的，在哪里定义的呢？就在那个让你困惑的里，有这么两行： #include #include 我们可以在头文件里找到_tmain的宏定义 #define _tmain main 所以，经过预编译以后， _tmain就变成main了 main()是标准C++的函数入口。标准C++的程序入口点函数,默认字符编码格式ANSI 函数签名为： int main(); int main(int argc, char* argv[]); _tmain()是windows提供的对unicode字符集和ANSI字符集进行自动转换用的程序入口点函数 函数签名为: int _tmain(int argc, TCHAR *argv[]) (1) 当你程序当前的字符集为... </summary> </entry> </feed>
