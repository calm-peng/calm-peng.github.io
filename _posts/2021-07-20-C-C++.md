---
title: C/C++
date: 2021-07-20 16:29
categories: [语言, C\C++]
tags: [C/C++]     # TAG names should always be lowercase
---
### 1、头文件

对于#include<filename.h>,编译器先从标准库路径开始搜索filename.h，使得系统文件调用比较快；
对于#include"filename.h"，编译器先从用户的工作路径开始搜索filename.h，后去寻找系统路径，使得自定义文件较快。所以在写代码的过程中要根据实际情况选择是<>还是""

头文件的作用有哪些？头文件的作用主要表现为以下两个方面：

(1)**通过头文件来调用库功能**。出于对源代码保密的考虑，源代码不便(或不准)向用户公布，只要向用户提供头文件和二进制的库即可。用户只需要按照头文件中的接口声明来调用库功能，而不必关心接口是怎么实现的，编译器会从库中提取相应的代码；

(2)**头文件能加强类型安全检查**。如果某个接口被实现或被调用时，其方式与头文件中的声明不一致，编译器就会指出错误，能大大减轻程序员调试、改错的负担。

### 2、程序的内存分配

一个由 c/C++编译的程序占用的内存分为以下几个部分
1、**栈区（stack）**—由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作
方式类似于数据结构中的栈。
2、**堆区（heap）**—一般由程序员分配释放，若程序员不释放，程序结束时可能由 OS 回收。
注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。
3、**全局区（静态区）（static）**—全局变量和静态变量的存储是放在一块的，初始化的全局
变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区
域。程序结束后由系统释放。
4、**文字常量区**—常量字符串就是放在这里的。程序结束后由系统释放。
5、**程序代码区**—存放函数体的二进制代码

### 3、关键字 static 的作用

这个简单的问题很少有人能回答完全。在 C 语言中，关键字 static 有三个明显的作用：
1) 在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。
2) 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但 不能被模块外其它函数访问。它是一个本地的全局变量。
3) 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个 函数被限制在声明它的模块的本地范围内使用。 、大多数应试者能正确回答第一部分，一部分能正确回答第二部分，同是很少的人能懂得第三 部分。这是一个应试者的严重的缺点，因为他显然不懂得本地化数据和代码范围的好处和重 要性。

### 4、“引用”与指针的区别

(1) 引用必须被初始化，指针不必。
(2) 引用初始化以后不能被改变，指针可以改变所指的对象。
(3) 不存在指向空值的引用，但是存在指向空值的指针。
指针通过某个指针变量指向一个对象后，对它所指向的变量间接操作。程序中使用指针，程 序的可读性差；而引用本身就是目标变量的别名，对引用的操作就是对目标变量的操作。 流操作符<<和>>、赋值操作符=的返回值、拷贝构造函数的参数、赋值操作符=的参数、其它情况都推荐使用引用。

### 5、堆（heap）和栈(stack)的区别

（1）申请方式
**stack**:由`系统自动分配`。例如，声明在函数中一个局部变量 int b;系统自动在栈中为 b 开辟空间
**heap**:需要`程序员自己申请`，并指明大小，在 c 中 malloc 函数 ，如 p1=(char*)malloc(10);；在 C++中用 new 运算符 ；如p2=(char*)malloc(10)；但是注意 p1、p2本身是在栈中的。
（2）申请后系统的响应
**栈**：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。
**堆**：首先应该知道操作系统有一个记录空闲内存地址的`链表`，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中 删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的 delete 语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放 入空闲链表中。
（3）申请大小的限制
**栈**：在 Windows 下,栈是向`低地址`扩展的数据结构，是一块`连续`的内存的区域。这句话的意 思是栈顶的地址和栈的最大容量是`系统预先规定好的`，在 WINDOWS 下，栈的大小是2M（也 有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将 提示 overflow。因此，能从栈获得的空间较小。
**堆**：堆是向`高地址`扩展的数据结构，是`不连续`的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。
（4）申请效率的比较：
**栈**:由系统自动分配，`速度较快`。但程序员是无法控制的。
**堆**:是由 new 分配的内存，`一般速度比较慢`，而且容易产生内存碎片,不过用起来最方便.
另外，在 WINDOWS 下，最好的方式是用 Virtual Alloc 分配内存，他不是在堆，也不是在 栈,而是直接在进程的地址空间中保留一块内存，虽然用起来最不方便。但是速度快，也最 灵活。
（5）堆和栈中的存储内容
**栈**：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的 C 编译器中，参数是由右往左入栈 的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，
也就是主函数中的下一条指令，程序由该点继续运行。
**堆**：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由`程序员`安排。
（6）存取效率的比较
栈比堆快

### 6、gcc ：预处理、编译、汇编、链接

生成可执行程序过程为成四个步骤：
1、由.c文件到.i文件，这个过程叫预处理。
2、由.i文件到.s文件，这个过程叫编译。
3、由.s文件到.o文件，这个过程叫汇编。
4、由.o文件到可执行文件，这个过程叫链接。

**1） 预处理**
以“#”号开头的预处理指令如包含#include,宏定义制定#define等。在源程序中这些指令都放在函数之外，而且一般放在源文件的前面。
使用预处理器把源文件test.c经过预处理生成test.i文件。
预处理的命令为：

```c
gcc -E test.c -o test.i
```

上述命令中-E是让编译器在预处理之后就退出，不进行后续编译过程；-o是指定输出文件名。在本例中，预处理结果就是将stdio.h 文件中的内容插入到test.c中了。
预处理生成的是test.i的文本文件，这个文本文件是可以直接通过cat命令进行文本文件查看的。

+ 宏定义指令，#define  a b
+ 条件编译指令，如#ifdef, #ifndef , #else , #elif , #endif等
+ 头文件包含指令，如#include"filename"
+ 特殊符号，预处理程序可以识别一些特殊符号

**2）编译**
这里的编译不是指程序从源文件到二进制程序的全部过程，而是指将经过预处理文件（test.i）之后的程序转换成特定汇编（test.s）代码的过程。
编译的命令为：

```c
gcc -S test.i -o test.s
```

上述命令中-S让编译器在编译之后停止，不进行后续过程；-o是指定输出文件名。编译过程完成后，将生成程序的汇编代码test.s，这也是文本文件。

+ 进行词法分析和语法分析
+ 优化处理（删除公共表达式，循环优化，复写传播，无用赋值的删除）

**3） 汇编**
汇编过程将上一步的汇编代码转换成机器码，这一步产生的文件叫做目标文件，是二进制格式。
汇编的命令为：

```c
gcc -c test.s -o test.o
```

**4） 链接**
链接过程使用链接器将该目标文件与其他目标文件、库文件、启动文件等链接起来生成可执行文件。附加的目标文件包括静态连接库和动态连接库。
链接过程的命令为：

```c
gcc test.o -o test
```

+ 静态链接（直接拷贝）
+ 动态链接

### 7、如何判断一段程序是由C 编译程序还是由C++编译程序编译的？

运用编译标志宏，窗体直接运行以下代码：

~~~ C
#include <iostream>

int main()
{
#ifdef __cplusplus
	printf("C++\n");
#else
	printf("c\n");
#endif
	system("pause");
	return 0;
}
~~~

### 8、C++函数中值的传递方式有哪几种?

值传递、指针传递和引用传递。

### 9、有了 malloc/free 为什么还要 new/delete？

malloc 与 free 是 C++/C 语言的标准库函数，new/delete 是 C++的运算符。它们都可用于申请动态内存和释放内存。 对于非内部数据类型的对象而言，光用 maloc/free 无法满足**动态对象**的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free 是**库函数而不是运算符**，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加malloc/free。 因此 C++语言需要一个能完成动态内存分配和初始化工作的运算符 new，以及一个能完成清理与释放内存工作的运算符 delete。注意 new/delete 不是库函数。

### 10、面向对象的三个基本特征，并简单叙述之？

（1）**封装**：将客观事物抽象成类，每个类对自身的数据和方法实行protection(private,protected,public)
（2）**继承**：广义的继承有三种实现形式：实现继承（指使用基类的属性和方法而无需额外编码的能力）、可视继承（子窗体使用父窗体的外观和实现代码）、接口继承（仅使用属性和方法，实现滞后到子类实现）。前两种（类继承）和后一种（对象组合=>接口继承以及纯虚函数）构成了功能复用的两种方式。
（3）**多态**：是将父对象设置成为和一个或更多的与他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。

### 11、重载（overload)、重写(override，有的书也叫做“覆盖”）、重定义（redefinition）的区别？

| 名称        | 名字空间       | 区别                                               |
| ----------- | -------------- | -------------------------------------------------- |
| 重载        | 同一名字子空间 | 是指允许存在多个同名函数，而这些函数的参数表不同。 |
| 重定义/隐藏 | 不同名字子空间 | 用于继承，派生类与基类的函数同名，屏蔽基类的函数   |
| 重写/覆盖   | 不同名字子空间 | 用于继承，子类重新定义父类虚函数的方法             |


### 12、多态的作用？

（1）隐藏实现细节，使得代码能够模块化；扩展代码模块，实现代码重用；
（2）接口重用：为了类在继承和派生的时候，保证使用家族中任一类的实例的某一属性时的正确调用。

### 13、所有的运算符都能重载吗？


在 C++运算符集合中，有一些运算符是不允许被重载的。这种限制是出于安全方面的考虑，可防止错误和混乱。
（1）不能改变 C++内部数据类型（如 int,float 等）的运算符。
（2）不能重载‘.’，因为‘.’在类中对任何成员都有意义，已经成为标准用法。
（3）不能重载目前 C++运算符集合中没有的符号，如#,@,$等。原因有两点，一是难以理解，二是难以确定优先级。
（4）对已经存在的运算符进行重载时，不能改变优先级规则，否则将引起混乱。
